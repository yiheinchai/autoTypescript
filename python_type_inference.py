"""
Python Type Inference

Converts captured runtime data into Python type hints and generates .pyi stub files.
"""

from typing import Any, Dict, List, Set, Optional, Union
import json


def infer_python_type(values: List[Any]) -> str:
    """
    Infer a Python type from a list of observed values.
    
    Args:
        values: List of runtime values
    
    Returns:
        Python type annotation string
    """
    if not values:
        return "Any"
    
    # Separate values by category
    type_set = set()
    list_values = []
    dict_values = []
    
    for value in values:
        if value is None:
            type_set.add("None")
        elif value == "[Function]":
            type_set.add("Callable")
        elif value == "[Max Depth Exceeded]" or value == "[Unserializable]":
            type_set.add("Any")
        elif isinstance(value, bool):
            type_set.add("bool")
        elif isinstance(value, int):
            type_set.add("int")
        elif isinstance(value, float):
            type_set.add("float")
        elif isinstance(value, str):
            type_set.add("str")
        elif isinstance(value, list):
            list_values.append(value)
        elif isinstance(value, dict):
            dict_values.append(value)
        else:
            type_set.add("Any")
    
    # Handle lists
    if list_values:
        element_types = []
        for lst in list_values:
            if lst:
                element_type = infer_python_type(lst)
                element_types.append(element_type)
        
        if element_types:
            # Find unique element types
            unique_types = list(set(element_types))
            if len(unique_types) == 1:
                type_set.add(f"List[{unique_types[0]}]")
            else:
                union_type = " | ".join(unique_types)
                type_set.add(f"List[{union_type}]")
        else:
            type_set.add("List[Any]")
    
    # Handle dicts
    if dict_values:
        dict_type = infer_dict_type(dict_values)
        type_set.add(dict_type)
    
    if not type_set:
        return "Any"
    
    types_list = sorted(list(type_set))
    if len(types_list) == 1:
        return types_list[0]
    
    # Create a Union type
    return " | ".join(types_list)


def infer_dict_type(dicts: List[Dict]) -> str:
    """
    Infer a Python TypedDict or Dict type from observed dictionary values.
    
    Args:
        dicts: List of dictionary values
    
    Returns:
        Python type annotation string
    """
    if not dicts:
        return "Dict[str, Any]"
    
    # Collect all keys and their values
    key_values: Dict[str, List[Any]] = {}
    key_counts: Dict[str, int] = {}
    total_dicts = len(dicts)
    
    for d in dicts:
        for key, value in d.items():
            if key not in key_values:
                key_values[key] = []
                key_counts[key] = 0
            key_values[key].append(value)
            key_counts[key] += 1
    
    # If no consistent structure, return generic Dict
    if not key_values:
        return "Dict[str, Any]"
    
    # Check if we can use a TypedDict (all dicts have similar structure)
    # For simplicity, we'll use Dict with a more specific value type
    all_values = []
    for values in key_values.values():
        all_values.extend(values)
    
    value_type = infer_python_type(all_values)
    
    # Create a dict type representation
    if len(key_values) <= 5:  # If small number of keys, show structure
        props = []
        for key in sorted(key_values.keys()):
            key_type = infer_python_type(key_values[key])
            is_required = key_counts[key] == total_dicts
            optional = "" if is_required else " | None"
            props.append(f'"{key}": {key_type}{optional}')
        return "{" + ", ".join(props) + "}"
    else:
        return f"Dict[str, {value_type}]"


def generate_pyi_stub(cache: Dict[str, Any], module_name: str = "") -> str:
    """
    Generate a Python .pyi stub file from the type cache.
    
    Args:
        cache: Type cache dictionary
        module_name: Optional module name for the stub
    
    Returns:
        Content of .pyi stub file
    """
    lines = [
        '"""Auto-generated type stubs from runtime data"""',
        '"""Generated by AutoPython"""',
        '',
        'from typing import Any, Dict, List, Callable, Optional, Union',
        '',
    ]
    
    if module_name:
        lines.append(f'# Module: {module_name}')
        lines.append('')
    
    # Generate function signatures
    for func_name, func_data in sorted(cache.items()):
        # Skip if no call data
        if func_data.get('callCount', 0) == 0:
            continue
        
        param_names = func_data.get('paramNames', [])
        param_data = func_data.get('paramData', {})
        
        # Build parameter list
        params = []
        max_params = len(param_names)
        
        # Check for observed parameters beyond declared ones
        if param_data:
            observed_indices = [int(k) for k in param_data.keys()]
            if observed_indices:
                max_params = max(max_params, max(observed_indices) + 1)
        
        for i in range(max_params):
            param_name = param_names[i] if i < len(param_names) else f"arg{i}"
            
            # Get observed values for this parameter
            observed_values = param_data.get(str(i), [])
            
            # Infer type from observed values
            param_type = infer_python_type(observed_values) if observed_values else "Any"
            
            # Handle *args and **kwargs
            if param_name.startswith('*'):
                if param_name.startswith('**'):
                    params.append(f"{param_name}: {param_type}")
                else:
                    params.append(f"{param_name}: {param_type}")
            else:
                params.append(f"{param_name}: {param_type}")
        
        params_str = ", ".join(params)
        
        # Extract just the function name (remove module prefix if present)
        simple_func_name = func_name.split('.')[-1]
        
        lines.append(f"def {simple_func_name}({params_str}) -> Any: ...")
        lines.append("")
    
    return "\n".join(lines)


def generate_all_stubs(cache: Dict[str, Any]) -> Dict[str, str]:
    """
    Generate .pyi stub files for all modules in the cache.
    
    Args:
        cache: Type cache dictionary
    
    Returns:
        Dictionary mapping module names to stub file contents
    """
    # Group functions by module
    modules: Dict[str, Dict[str, Any]] = {}
    
    for func_name, func_data in cache.items():
        # Extract module name from fully qualified function name
        parts = func_name.split('.')
        if len(parts) > 1:
            module_name = '.'.join(parts[:-1])
            simple_name = parts[-1]
        else:
            module_name = "__main__"
            simple_name = func_name
        
        if module_name not in modules:
            modules[module_name] = {}
        
        modules[module_name][simple_name] = func_data
    
    # Generate stub for each module
    stubs = {}
    for module_name, module_cache in modules.items():
        stub_content = generate_pyi_stub(module_cache, module_name)
        stubs[module_name] = stub_content
    
    return stubs


def cache_stats(cache: Dict[str, Any]) -> Dict[str, int]:
    """
    Get statistics about the type cache.
    
    Args:
        cache: Type cache dictionary
    
    Returns:
        Dictionary with statistics
    """
    total_functions = len(cache)
    total_calls = sum(func_data.get('callCount', 0) for func_data in cache.values())
    
    return {
        'functionCount': total_functions,
        'totalCalls': total_calls
    }
